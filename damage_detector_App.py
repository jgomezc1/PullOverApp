# -*- coding: utf-8 -*-
"""
Created on Sat Jul 19 14:39:29 2025

@author: jgomez
"""

#########################################################################################################
#                                                                                                       #
# This files stores functions to detect if a given element experienced inelastic response on the basis  #
# of the yield moments defined on the Model Object. The functions compare Moment values read from       #
# forces files generated by OpenSees recorders with these available in the model object definition      #
#                                                                                                       #
#########################################################################################################


import os
import numpy as np
import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import traceback

def plot_multiple_moment_vs_curvature(plot_info, damage_dir, yield_params_config, num_cols=3):
    """
    Generates a grid of Moment-Curvature plots for multiple damaged elements.
    """
    if not plot_info:
        fig = go.Figure()
        fig.add_annotation(x=0.5, y=0.5, text="No damaged elements selected to plot.", showarrow=False, xref="paper", yref="paper", font=dict(size=20, color="gray"))
        fig.update_layout(height=400, width=600)
        return fig

    elements_to_plot = list(plot_info.keys())
    num_plots = len(elements_to_plot)
    num_rows = (num_plots + num_cols - 1) // num_cols

    subplot_titles = []
    for ele_id in elements_to_plot:
        info = plot_info[ele_id]
        damage_details = info.get('damage_details', {})
        ductility_data = info.get('ductility_data', pd.Series())
        
        selected_axis, selected_sec = 'My', 1 
        for key, status in damage_details.items():
            if status == 'Damaged':
                parts = key.split('_')
                selected_axis = parts[0]
                selected_sec = int(parts[1].replace('Sec', ''))
                break
        
        ductility_col_name = f'Ductility_{selected_axis}_Sec{selected_sec}'
        ductility_val = ductility_data.get(ductility_col_name, 0.0)
        
        title = f"Ele {ele_id} ({selected_axis} Sec {selected_sec})<br>Ductility: {ductility_val:.2f}"
        subplot_titles.append(title)

    fig = make_subplots(rows=num_rows, cols=num_cols, subplot_titles=subplot_titles, vertical_spacing=0.15, horizontal_spacing=0.08)

    row_idx, col_idx = 1, 1
    for ele_id in elements_to_plot:
        info = plot_info[ele_id]
        damage_details = info.get('damage_details', {})
        
        element_type = info['ductility_data'].get('Element Type')
        yield_params_for_ele = yield_params_config.get(element_type, {})

        axis_to_plot, sec_to_plot = 'My', 1
        for key, status in damage_details.items():
            if status == 'Damaged':
                parts = key.split('_'); axis_to_plot = parts[0]; sec_to_plot = int(parts[1].replace('Sec', '')); break
        
        force_file = os.path.join(damage_dir, f'Rele{ele_id}_h{sec_to_plot}_force.out')
        deform_file = os.path.join(damage_dir, f'Rele{ele_id}_h{sec_to_plot}_deformation.out')

        if os.path.exists(force_file) and os.path.exists(deform_file):
            try:
                force_data = np.loadtxt(force_file)
                deform_data = np.loadtxt(deform_file)
                
                moment_idx_map = {'My': 3, 'Mz': 6}
                curv_idx_map = {'My': 5, 'Mz': 2}

                M = force_data[:, moment_idx_map[axis_to_plot]]
                kappa = deform_data[:, curv_idx_map[axis_to_plot]]

                fig.add_trace(go.Scatter(x=kappa, y=M, mode='lines', name=f'M-κ ({axis_to_plot})', line=dict(color='blue', width=1.5), showlegend=False), row=row_idx, col=col_idx)
                
                yield_moment_key = 'My_yield_x' if axis_to_plot == 'My' else 'Mz_yield_x'
                yield_moment = yield_params_for_ele.get(yield_moment_key)

                if yield_moment is not None:
                    fig.add_shape(type="line", x0=min(kappa), y0=yield_moment, x1=max(kappa), y1=yield_moment, line=dict(color="red", width=1, dash="dash"), row=row_idx, col=col_idx)
                    fig.add_shape(type="line", x0=min(kappa), y0=-yield_moment, x1=max(kappa), y1=-yield_moment, line=dict(color="red", width=1, dash="dash"), row=row_idx, col=col_idx)
                
                epsilon = 1e-10
                x_range = max(kappa) - min(kappa) if len(kappa) > 1 else 0
                y_range = max(M) - min(M) if len(M) > 1 else 0
                x_pad = x_range * 0.1 if x_range > epsilon else 0.001
                y_pad = y_range * 0.1 if y_range > epsilon else 1000
                
                fig.update_xaxes(title_text='Curvature [1/m]', row=row_idx, col=col_idx, showgrid=True, zeroline=True, range=[min(kappa)-x_pad, max(kappa)+x_pad], tickformat=".1e", title_font_size=10, tickfont_size=8)
                fig.update_yaxes(title_text='Moment [N-m]', row=row_idx, col=col_idx, showgrid=True, zeroline=True, range=[min(M)-y_pad, max(M)+y_pad], tickformat=".1e", title_font_size=10, tickfont_size=8)

            except Exception as e:
                print(f"Error plotting M-κ for Element {ele_id}: {e}\n{traceback.format_exc()}")
                fig.add_annotation(text=f"Plot Error: {ele_id}", xref="x domain", yref="y domain", x=0.5, y=0.5, showarrow=False, font=dict(color="red", size=12), row=row_idx, col=col_idx)
        
        col_idx += 1
        if col_idx > num_cols:
            col_idx = 1
            row_idx += 1

    fig.update_layout(title_text=f"Moment-Curvature Response for Damaged Elements", height=num_rows * 400, showlegend=False, margin=dict(l=40, r=40, b=40, t=60))
    return fig


def detect_damaged_elements_by_moment(damage_config, damage_dir):
    """
    Detects damaged elements by iterating through element ranges defined in the config.
    """
    yield_params = damage_config.get('yield_parameters', {})
    element_ranges = damage_config.get('element_ranges', [])
    base_cost = damage_config.get('base_cost_per_element', 15000)
    margin = damage_config.get('margin', 0.99) 

    if not yield_params or not element_ranges:
        print("⚠️ 'yield_parameters' or 'element_ranges' not found in damage_config.")
        return pd.DataFrame(), {}

    damage_summary = []
    damage_map = {}
    
    moment_column_map = {'My': 3, 'Mz': 6}
    curv_column_map = {'My': 5, 'Mz': 2}
    
    for ele_range in element_ranges:
        range_type = ele_range['type']
        start_ele = ele_range['start_ele']
        end_ele = ele_range['end_ele']
        
        params_for_range = yield_params.get(range_type)
        if not params_for_range:
            print(f"Warning: Yield parameters for type '{range_type}' not found. Skipping range {start_ele}-{end_ele}.")
            continue

        for ele_id in range(start_ele, end_ele + 1):
            result = {'Element': ele_id, 'Element Type': range_type}
            element_damage_details = {}
            is_element_damaged = False
            current_ele_duct_cols = []

            for sec_id in [1, 4]: 
                for axis in ['My', 'Mz']:
                    status_key = f'{axis}_Sec{sec_id}'
                    ductility_key = f'Ductility_{status_key}'
                    result[ductility_key] = 0.0
                    current_ele_duct_cols.append(ductility_key)

                    force_file = os.path.join(damage_dir, f'Rele{ele_id}_h{sec_id}_force.out')
                    deform_file = os.path.join(damage_dir, f'Rele{ele_id}_h{sec_id}_deformation.out')

                    if not os.path.exists(force_file) or not os.path.exists(deform_file):
                        result[status_key] = 'No File'
                        continue
                    
                    try:
                        force = np.loadtxt(force_file)
                        deform = np.loadtxt(deform_file)
                        
                        if force.ndim < 2 or deform.ndim < 2 or force.size == 0 or deform.size == 0:
                            result[status_key] = 'Invalid Data'
                            continue

                        moment = force[:, moment_column_map[axis]]
                        curvature = deform[:, curv_column_map[axis]]
                        
                        yield_moment_key = 'My_yield_x' if axis == 'My' else 'Mz_yield_x'
                        yield_curv_key = 'phi_yield_y' if axis == 'My' else 'phi_yield_z'
                        
                        if yield_moment_key not in params_for_range:
                             if axis == 'My': yield_moment_key = 'My_yield_y'
                             elif axis == 'Mz': yield_moment_key = 'Mz_yield_y'
                             if yield_moment_key not in params_for_range:
                                 result[status_key] = 'No Threshold'
                                 continue

                        threshold = params_for_range[yield_moment_key] * margin
                        yield_curvature = params_for_range.get(yield_curv_key, 1.0)
                        
                        if np.any(np.abs(moment) > threshold):
                            result[status_key] = 'Damaged'
                            is_element_damaged = True
                            element_damage_details[status_key] = 'Damaged'
                            
                            max_curvature = np.max(np.abs(curvature))
                            if yield_curvature > 1e-9:
                                ductility = max_curvature / yield_curvature
                                result[ductility_key] = ductility
                            else:
                                result[ductility_key] = np.inf
                        else:
                            result[status_key] = 'Elastic'
                    except Exception as e:
                        result[status_key] = f'Error'
                        print(f"Error processing ele {ele_id}, sec {sec_id}, axis {axis}: {e}")

            if is_element_damaged:
                temp_df = pd.DataFrame([result])
                max_ductility = temp_df[current_ele_duct_cols].max(axis=1).iloc[0]
                
                damage_state = "None"
                rcf = 0.0 
                
                if max_ductility >= 4.0:
                    damage_state = 'Severe'
                    rcf = 1.0
                elif max_ductility >= 2.0:
                    damage_state = 'Moderate'
                    rcf = 0.5
                elif max_ductility >= 1.0:
                    damage_state = 'Minor'
                    rcf = 0.15
                
                result['Damage State'] = damage_state
                result['Repair Cost Factor'] = rcf
                result['Estimated Cost ($)'] = base_cost * rcf

                damage_summary.append(result)
                damage_map[ele_id] = element_damage_details

    if damage_summary:
        df = pd.DataFrame(damage_summary)
        cols = df.columns.tolist()
        ele_col = ['Element', 'Element Type']
        cost_cols = ['Damage State', 'Repair Cost Factor', 'Estimated Cost ($)']
        status_cols = sorted([c for c in cols if c.startswith(('My_', 'Mz_'))])
        ductility_cols = sorted([c for c in cols if c.startswith('Ductility')])
        
        final_cols = ele_col + cost_cols + status_cols + ductility_cols
        final_cols = [c for c in final_cols if c in df.columns]
        df = df[final_cols]
        df = df.round(2)
        return df, damage_map
    else:
        return pd.DataFrame(), {}